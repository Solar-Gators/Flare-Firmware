name: CI

on:
  push:
  pull_request:

permissions:
  contents: read

jobs:
  format:
    name: clang-format check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Pin to the same major you use locally (rev v17.0.6 in pre-commit)
      - name: Install clang-format 17
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-format-17
          sudo ln -sf /usr/bin/clang-format-17 /usr/local/bin/clang-format
          clang-format --version

      - name: Run clang-format (verify no diffs)
        shell: bash
        run: |
          set -eo pipefail
          echo "Checking formatting (user/ + SG_Drivers only)..."

          # Collect only our sources (avoid HAL/CMSIS/Middlewares/etc)
          mapfile -d '' -t FILES < <(
            find \
              firmware -path 'firmware/*/user/*' -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) -print0
          )
          mapfile -d '' -t SG_FILES < <(
            find \
              resources/Drivers/SG_Drivers -type f \( -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' \) -print0
          )
          FILES=("${FILES[@]}" "${SG_FILES[@]}")

          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No source files found to check."
            exit 0
          fi

          # Dry-run check; fail if formatting would change
          printf '%s\0' "${FILES[@]}" | xargs -0 -n 100 clang-format -style=file -n --Werror
  build:
    name: Build (Debug & Release)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        preset: [debug, release]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install ARM GCC & build deps
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            cmake \
            gcc-arm-none-eabi \
            binutils-arm-none-eabi \
            libnewlib-arm-none-eabi

      - name: Configure (${{ matrix.preset }})
        run: cmake --preset ${{ matrix.preset }}

      - name: Build (${{ matrix.preset }})
        run: cmake --build --preset ${{ matrix.preset }} --target all

      - name: Collect firmware artifacts (.elf/.hex only, grouped by project)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          preset="${{ matrix.preset }}"

          # Start clean for this preset
          rm -rf "artifacts" || true

          # Find only firmware outputs; skip CMake scratch dirs
          mapfile -d '' -t FILES < <(
            find "build/${preset}/firmware" \
              -type d \( -name 'CMakeFiles*' -o -name 'CMakeScratch*' \) -prune -o \
              -type f \( -name '*.elf' -o -name '*.hex' \) -print0 2>/dev/null || true
          )

          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No .elf/.hex files found under build/${preset}/firmware"
            exit 0
          fi

          for f in "${FILES[@]}"; do
            # Project name = first dir under build/<preset>/firmware/
            # e.g., build/release/firmware/project1/...
            rel="${f#build/${preset}/firmware/}"
            project="${rel%%/*}"

            # Extension and destination subfolder (".elf" or ".hex")
            ext="${f##*.}"
            dest="artifacts/${project}/${preset}/.${ext}"
            mkdir -p "${dest}"

            # Keep original filename; copy into the right bucket
            cp -v -- "$f" "${dest}/"
          done

          echo "Collected tree:"
          find artifacts -type f | sort

      - name: Upload artifacts (${{ matrix.preset }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ matrix.preset }}
          path: artifacts/*/${{ matrix.preset }}/
          if-no-files-found: warn

